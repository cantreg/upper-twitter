'use strict';

// Do this as the first thing so that any code reading it knows the right env.
process.env.BABEL_ENV = 'development';
process.env.NODE_ENV = 'development';

// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on('unhandledRejection', err => {
    throw err;
});

// Ensure environment variables are read.
require('../config/env');

const TwitterApi = require('./TwitterApi');
const fs = require('fs');
const chalk = require('chalk');
const webpack = require('webpack');
const express = require('express');
const WebpackDevServer = require('webpack-dev-server');
const clearConsole = require('react-dev-utils/clearConsole');
const checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');
const {
    choosePort,
    createCompiler,
    prepareProxy,
    prepareUrls,
} = require('react-dev-utils/WebpackDevServerUtils');
const openBrowser = require('react-dev-utils/openBrowser');
const paths = require('../config/paths');
const config = require('../config/webpack.config.dev');
const createDevServerConfig = require('../config/webpackDevServer.config');

const useYarn = fs.existsSync(paths.yarnLockFile);
const isInteractive = process.stdout.isTTY;

// Warn and crash if required files are missing
if (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) {
    process.exit(1);
}

// Tools like Cloud9 rely on this.
const FRONTEND_PORT = parseInt(process.env.PORT, 10) || 3000;
const BACKEND_PORT = 5000;
const HOST = process.env.HOST || '0.0.0.0';
var EXTERNAL_IP;
getIp().then((ip) => {
    EXTERNAL_IP = ip;
    console.log("External ip: "+EXTERNAL_IP);
}).catch(() => {
        process.exit()
    }
);

if (process.env.HOST) {
    console.log(
        chalk.cyan(
            `Attempting to bind to HOST environment variable: ${chalk.yellow(
                chalk.bold(process.env.HOST)
            )}`
        )
    );
    console.log(
        `If this was unintentional, check that you haven't mistakenly set it in your shell.`
    );
    console.log(`Learn more here: ${chalk.yellow('http://bit.ly/2mwWSwH')}`);
    console.log();
}

Promise.resolve(getFrontendDevServer())
    .then(launchBackendExpress)
    .then(launchFrontendDevServer);

function getFrontendDevServer() {
    const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
    const appName = require(paths.appPackageJson).name;
    const urls = prepareUrls(protocol, HOST, FRONTEND_PORT);
// Create a webpack compiler that is configured with custom messages.
    const compiler = createCompiler(webpack, config, appName, urls, useYarn);
// Load proxy config
    const proxySetting = require(paths.appPackageJson).proxy;
    const proxyConfig = prepareProxy(proxySetting, paths.appPublic);
// Serve webpack assets generated by the compiler over a web sever.
    const serverConfig = createDevServerConfig(
        proxyConfig,
        urls.lanUrlForConfig
    );
    const frontendWebpackDevServer = new WebpackDevServer(compiler, serverConfig);

    return frontendWebpackDevServer;
}

function launchFrontendDevServer(servers) {
    return new Promise((resolve, reject) => {
        let {frontendWebpackDevServer, backendExpressServer} = servers;
        // Launch WebpackDevServer.
        frontendWebpackDevServer.listen(FRONTEND_PORT, HOST, err => {
            if (err) {
                console.log(err);
                reject(err);
            }
            if (isInteractive) {
                clearConsole();
            }
            console.log(chalk.cyan(`Starting frontend development server on port ${FRONTEND_PORT}...\n`));
            //openBrowser(urls.localUrlForBrowser);
        });

        resolve(servers);
    });
}

function launchBackendExpress(frontendWebpackDevServer) {
    return new Promise((resolve, reject) => {
        const backendExpressServer = express();
        var session = require('express-session')
        backendExpressServer.use(session({ resave: true, secret: '123456' , saveUninitialized: true}));
        backendExpressServer.get('/api/user_timeline', tweetsApplicationTokenHandler);
        backendExpressServer.get('/api/home_timeline', tweetsApplicationTokenHandler);
        backendExpressServer.get('/api/login', redirectToTwitterAuthorize);
        backendExpressServer.get('/api/access-token', redirectToTwitterLogin);

        backendExpressServer.listen(BACKEND_PORT, () => console.log(`Backend app express server listening on port ${BACKEND_PORT}`));

        ['SIGINT', 'SIGTERM'].forEach(function (sig) {
            process.on(sig, function () {
                frontendWebpackDevServer.close();
                process.exit();
            });
        });

        resolve({frontendWebpackDevServer, backendExpressServer});
    });
}

function redirectToTwitterAuthorize(req, res) {
    TwitterApi.redirectToTwitterAuthorizePage(req, res, EXTERNAL_IP, BACKEND_PORT);
}

function redirectToTwitterLogin(req, res) {
    TwitterApi.redirectToTwitterLoginPage(req, res, EXTERNAL_IP, FRONTEND_PORT);
}

var token = null;
function tweetsApplicationTokenHandler(req, res) {

    var name = 'F_A_L_L_E_N';
    var count = 10;
    var params = {name, count};

    var sinceId = req.query.afterId;
    var maxId = req.query.beforeId;
    if(sinceId || maxId) {
        Object.assign(params, {sinceId, maxId});
    }
    var getParams;
    if (!token) {
        getParams = new Promise((resolve, reject) => {
            try {
                TwitterApi.getApplicationToken((access_token) => {
                    token = access_token
                    Object.assign(params, {token});
                    resolve(params);
                });
            } catch (e) {
                reject(e);
            }
        });
    } else {
        getParams = Promise.resolve(params)
    }
    getParams
        .then(TwitterApi.getUserTweetsWithAppToken)
        .then((tweets) => {
            allowOrigin(res);
            if(maxId) tweets = tweets.splice(1, tweets.length-1);
            res.send(tweets);
        });
}
function tweetsApplicationTokenHandler(req, res) {

    var name = 'F_A_L_L_E_N';
    var count = 10;
    var params = {name, count};

    var sinceId = req.query.afterId;
    var maxId = req.query.beforeId;
    if(sinceId || maxId) {
        Object.assign(params, {sinceId, maxId});
    }
    TwitterApi.promiseUserTweetsWithAccessToken().then((result) => {
        var tweets = JSON.parse(result);
        console.log(tweets); // the tweets!
        if(maxId) tweets = tweets.splice(1, tweets.length-1);
        allowOrigin(res);
        res.send(tweets);
    });
}

function allowOrigin(res) {
    res.header('Access-Control-Allow-Origin', 'http://' + EXTERNAL_IP + ':' + FRONTEND_PORT);
    res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
}

function getIp() {
    return new Promise((resolve, reject) => {
            let options = {
                method: 'GET',
                url: 'https://api.ipify.org?format=json',
                json: true,
            };
            var rp = require('request-promise');
            rp(options).then((result) => {
                resolve(result.ip);
            }).catch((e) => {
                    console.log(e);
                    reject(e);
                }
            );
        });
}